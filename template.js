// Generated by the ffmpeg bundler, DO NOT EDIT!


(function(){
	// ffmpeg.js file used to load in the other files
	FFMPEG_LOADER

	// We need to force ffmpeg not to create
	// the worker as a module, otherwise blobs
	// fail to load
	const old_worker = window.Worker;
	let worker_hacked = function(url, ...ignored){
		return new old_worker(url);
	}

	// Repair atob's result
	function base64ToBytes(base64) {
	    const binaryString = atob(base64);
	    return new Uint8Array(binaryString.length).map((_, i) => binaryString.charCodeAt(i));
	}

	// Use base64 blobs to create replicate the
	// other files byte-for-byte.
	let core_blob = URL.createObjectURL(new Blob([base64ToBytes("FFMPEG_CORE")], { type: "application/javascript" }));
	let worker_blob = URL.createObjectURL(new Blob([base64ToBytes("FFMPEG_WORKER")], { type: "application/javascript" }));
	let wasm_blob = URL.createObjectURL(new Blob([base64ToBytes("FFMPEG_WASM")], { type: "application/wasm" }));


	window.ffmpeg = new FFmpegWASM.FFmpeg();	
	
	// Prime with modified worker function
	Window.worker = worker_hacked;
	ffmpeg.load({
		classWorkerURL: worker_blob,
	    coreURL: core_blob,
		wasmURL: wasm_blob
	}).then(()=>{
		// Reset to the old worker class to prevent side affects
		Window.worker = old_worker;
	});
})();